import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product } from './product.entity';

@Injectable()
export class BarcodeGeneratorService {
    private readonly logger = new Logger(BarcodeGeneratorService.name);
    private readonly PREFIX = 'SP';
    private readonly BARCODE_LENGTH = 8; // SP + 5 digits = SP00001

    constructor(
        @InjectModel(Product.name) private readonly productModel: Model<Product>,
    ) { }

   
    async generateUniqueBarcode(): Promise<string> {
        this.logger.log('Generating unique barcode...');

        try {
            // Tìm barcode cuối cùng có format SPxxxxx
            const lastProduct = await this.productModel
                .findOne({
                    barcode: { $regex: `^${this.PREFIX}\\d{5}$` }, // Chỉ tìm SP + 5 số
                    isDelete: false
                })
                .sort({ barcode: -1 }) // Sort theo barcode desc để lấy số lớn nhất
                .select('barcode')
                .lean();

            let nextNumber = 1;

            if (lastProduct?.barcode) {
                // Extract số từ barcode (SP00001 -> 00001 -> 1)
                const currentNumber = parseInt(lastProduct.barcode.substring(this.PREFIX.length));
                nextNumber = currentNumber + 1;
                this.logger.log(`Last barcode found: ${lastProduct.barcode}, next number: ${nextNumber}`);
            } else {
                this.logger.log('No existing barcode found, starting from 1');
            }

            // Tạo barcode và check unique
            let attempts = 0;
            const maxAttempts = 1000;

            while (attempts < maxAttempts) {
                const barcode = this.formatBarcode(nextNumber);

                // Check xem barcode này đã tồn tại chưa
                const existingProduct = await this.productModel
                    .findOne({
                        barcode: barcode,
                        isDelete: false
                    })
                    .lean();

                if (!existingProduct) {
                    this.logger.log(`Generated unique barcode: ${barcode}`);
                    return barcode;
                }

                // Nếu trùng thì tăng số lên
                nextNumber++;
                attempts++;
                this.logger.warn(`Barcode ${barcode} already exists, trying next number: ${nextNumber}`);
            }

            // Fallback nếu không tìm được số sequence
            const timestamp = Date.now().toString().slice(-5);
            const fallbackBarcode = `${this.PREFIX}${timestamp}`;
            this.logger.warn(`Could not find sequential number after ${maxAttempts} attempts, using timestamp: ${fallbackBarcode}`);

            return fallbackBarcode;

        } catch (error) {
            this.logger.error('Error generating barcode:', error);

            // Emergency fallback
            const emergency = `${this.PREFIX}${Date.now().toString().slice(-5)}`;
            this.logger.error(`Using emergency barcode: ${emergency}`);
            return emergency;
        }
    }

    /**
     * Format number thành barcode với leading zeros
     * 1 -> SP00001, 123 -> SP00123
     */
    private formatBarcode(number: number): string {
        const numberStr = number.toString().padStart(5, '0');
        return `${this.PREFIX}${numberStr}`;
    }

    /**
 * Validate barcode format - now accepts any non-empty string
 */
    validateBarcodeFormat(barcode: string): boolean {
        if (!barcode) return false;

        // Check minimum length
        if (barcode.trim().length < 1) return false;

        // Allow any format - no restrictions
        return true;
    }

    /**
 * Check if barcode is auto-generated format (SP + exactly 5 digits)
 */
    isAutoGeneratedFormat(barcode: string): boolean {
        return /^SP\d{5}$/.test(barcode);
    }

    /**
     * Check if barcode follows any numeric pattern for suggestions
     */
    isNumericPattern(barcode: string): boolean {
        return /^\d+$/.test(barcode);
    }

    /**
     * Get next available number for manual entry suggestion
     */
    async getNextAvailableNumber(): Promise<number> {
        try {
            const lastProduct = await this.productModel
                .findOne({
                    barcode: { $regex: `^${this.PREFIX}\\d{5}$` },
                    isDelete: false
                })
                .sort({ barcode: -1 })
                .select('barcode')
                .lean();

            if (lastProduct?.barcode) {
                const currentNumber = parseInt(lastProduct.barcode.substring(this.PREFIX.length));
                return currentNumber + 1;
            }

            return 1;
        } catch (error) {
            this.logger.error('Error getting next available number:', error);
            return 1;
        }
    }

    /**
     * Check if custom barcode is available
     */
    async isBarcodeAvailable(barcode: string): Promise<boolean> {
        try {
            const existingProduct = await this.productModel
                .findOne({
                    barcode: barcode,
                    isDelete: false
                })
                .lean();

            return !existingProduct;
        } catch (error) {
            this.logger.error('Error checking barcode availability:', error);
            return false;
        }
    }

    /**
 * Suggest alternative barcodes if the desired one is taken
 */
    async suggestAlternativeBarcodes(desiredBarcode: string, count: number = 5): Promise<string[]> {
        const suggestions: string[] = [];

        try {
            // Nếu là format auto-generated SP, suggest số tiếp theo
            if (this.isAutoGeneratedFormat(desiredBarcode)) {
                const baseNumber = parseInt(desiredBarcode.substring(this.PREFIX.length));

                for (let i = 1; i <= count; i++) {
                    const newNumber = baseNumber + i;
                    const suggestion = this.formatBarcode(newNumber);

                    if (await this.isBarcodeAvailable(suggestion)) {
                        suggestions.push(suggestion);
                    }
                }
            }
            // Nếu là số thuần, suggest số tiếp theo
            else if (this.isNumericPattern(desiredBarcode)) {
                const baseNumber = parseInt(desiredBarcode);

                for (let i = 1; i <= count; i++) {
                    const suggestion = (baseNumber + i).toString();

                    if (await this.isBarcodeAvailable(suggestion)) {
                        suggestions.push(suggestion);
                    }
                }
            }
            // Cho format khác, suggest với suffix
            else {
                for (let i = 1; i <= count; i++) {
                    const suggestion = `${desiredBarcode}_${i}`;

                    if (await this.isBarcodeAvailable(suggestion)) {
                        suggestions.push(suggestion);
                    }
                }
            }

            // Luôn suggest format auto-generated SP làm backup
            const nextAuto = await this.generateUniqueBarcode();
            if (!suggestions.includes(nextAuto)) {
                suggestions.push(nextAuto);
            }

        } catch (error) {
            this.logger.error('Error suggesting alternative barcodes:', error);
        }

        return suggestions;
    }
} 